ls -l - полная информация о файлах (слева распределение read write exec, для трех юзеров, которые прописаны далее)
ls -a - показвает скрытые файлы,которые начинаются с точки .lib например
ls имя_папки - показывает что в папке (могу сделать ls -l имя_папки)
~ - переход в домашнюю директорию, ~/имя_папки - переход в имя_папки относительно домашней директории
mv имя_файла новое_имя_файла - переименовываю файл
mv имя_файла имя_папки/ - перемещаю файл в папку
mv имя_файла имя_папки/новое_имя_файла - не только переношу файл в папку, но и переименовываю его
mv имя_папки новое_имя_папки - переименовываю папку
. - директория в которой нахожусь, например хочу перенести файл из директории в ту где сейчас нахожусь: mv docs/text.txt .
cp имя_файла новое_имя_файла - копирую файл
cp -r имя_папки новое_имя_папки
mkdir -p имя_папки/имя_папки/имя_папки - могу создать папку с какой угодно вложенностью
tasklist или top - программа для показа процессов (1-для винды, 2е для линукс прога top)
ps - показывает программы которые на данный момент активны
ps -W - показывает все процессы, как будто прогой top
tasklist /v или ps aux - показывает все процессы (1-для винды, 2е для линукс)
(например ps aux|grep номер_процесса)
taskkill /f /im номер_процесса  или kill -TERM номер_процесса/kill -9 номер_процесса - убиваю процесс (1-для винды, 2е для линукс -TERM - мягко -KILL - жестко)
kill -STOP номер_процесса - тоже что и ctrl+z
tasklist | grep "имя_процесса" или ps aux | grep "имя процесса" - ищу во всех прцессах нужный мне
jobs - показвает все процессы в действующей сессии
ctrl+z - приостановить процесс выполнения программы
fg - вернуться к этой программе
fg номер_job - вернуться к процессу номер которого указан
название_программы & - запускает прогу и сразу отправляет ее в режим бекграунда
ctrl+c - остановка программы


Работа с юзером:
whoami - узнать свой логин
sudo adduser имя_юзера - добавить юзера (после этого нужно будет создать пароль для юзера)
su имя_юзера - сменить имя пользователя
exit - выхожу из режима юзера на который заходил
chmod u/g/o+r/w/x имя_файла - меняю разрешение доступа для usera/group/other, затем + т.е добавляю разрешение(убрать разрешение -), далее пишу что разрешить: read/write/execute, затем имя файла. Затем делаю ls -l и могу посмотреть, первая группа rwx - для юзера, вторая для группы, 3я для остальных. Если хочу добавить для всех то не указываю для кого конкретно даю доступ (chmod +x имя_файла)
chmod цифры_разрешения имя_файла - например chmod 777 test.txt - цифры в восьмизначной системы счисления read - 4, write - 2, execute - 1, если хочу сделать определнное разрешение просто плюсую. Если ничего не разрешаю ставлю 0.
chown имя_юзера имя_файла - меняю кому принадлежит файл
chown :имя_группы имя_файла - меняю кому принадлежит файл группа
chown имя_юзера:имя_группы имя_файла - меняю кому принадлежит файл и юзера и группа
sudo - позволяет выполнять команды как superuser, когда на новом компе/сервере я - это root - те могу делать все что угодно, чтобы избежать проблем лучше создать юзера и использовать sudo.
!! - выплнение предыдущей команды (могу сделать sudo !! - чтобы повторить предыдущую команду под суперюзером)



Работа с переменными:
env - выводит все переменные на пк
echo - выводит переменную (например echo $HOME - выведет переменную HOME)

Чтобы создать/поменять переменную пишу так: имя_переменной="значение", например PS1="\w >"
Чтобы сделать глобальную переменную пишу export имя_переменной="значение", например export MESSAGE="Hi"


bash - запускает новую сессию в текущей. Выйти из нее exit.

which имя_команды - показывает где находится файл с командой (берется из $PATH)
export PATH=путь_файла:$PATH - экспортирую новый путь в $PATH. $PATH-на конце значит, что сперва будет новый путь, затем в конце остальное. Пример: export PATH=/home/bin:$PATH

Существует файл, который запускается каждый раз когда запускаю bash console, называется по-разному, например .bashrc - в нем я добавляю, например, export PATH=/home/bin:$PATH, чтобы это запускалось каждый раз, когда запускаю консоль.

find директория_где_искать -name "имя_файла" - ищемт файлы, пример: find . -name "test.txt", могу искать в папке, если знаю в какой: find путь_к_папке -name "имя_файла"
find директория_где_искать -name  "имя_файла"  2> error_log.txt - найдет файл в директория_где_искать, а ошибки запишет в error_log.txt (2 - номер для ошибок)
find директория_где_искать -name  "имя_файла"  2> /dev/null - тоже самое, но теперь ошибки попадут не в отдельный файл, а просто пропадут, так как идет редирект на специальное место /dev/null
find . -type f -name  "console.log" - рекурсивно ищу console.log

grep "что_ищу" имя_файла - ищу что-либо в файле, пример grep "is" test.txt
grep -n "что_ищу" имя_файла - ищу в файле, результат показывается вместе со строкой
grep -i "что_ищу" имя_файла - ищу в файле, результат регистронезависим
grep -v "что_ищу" имя_файла - ищу все кроме "что_ищу"
man grep, man find - мануалы по grep и find
grep что_ищу имя_файла > имя_нового_файла - тут указываю что хочу найти в файле имя_файла и записать, то что нашел в имя_нового_файла (вся инфа в новом файле перезаписывается)
grep что_ищу имя_файла >> имя_нового_файла - тоже, но теперь инфа в новом файле не перезаписывается, а добавляется.

| - берет выходные данные процесса слева и делает их входными для процесса справа, например беру ps aux | grep bash - те ищу процесс bash во всех процессах. Тем самым могу объединять несколько процессов в один, например ps aux | grep bash | sort > bash.txt - ищу все процессы bash, сортирую их, и записываю в файл bash.txt

ctrl+d - дать знак к окончанию программы 


Поиск файлов и каталогов
find . -name '<name>' (find -name "*.css" - найти все css)
- найти файлы по имени
find . -size +1M
- найти файлы размером более 1МБ
find /var/tmp -size +1M | xargs rm
- найти файлы размером более 1МБ и удалить их
find /var/tmp -size +1M -print0 | xargs -0 rm
- тоже самое, только пробельные символы в имени файлов будут заменены нулями
find . -name '*' | xargs grep -E $'\t'
- найти файлы, содержащие символы табуляции
find . -not -type d -exec file "{}" ";" | grep CRLF
- найти файлы, содержащие переводы строк в формате Windows



Если поставить | more в конец то будет выводиться результат пофайльно



Инсталяция ПО
Установка без package manager
sudo apt-get update - апдейт всего ПО на Ubuntu
sudo apt-get install build-essential - установка инструментов для установки ПО
which имя_программы - показывает где установлена прога
curl -O URL_файла - загружаю файл из интернета (-О - сохраняет файл, curl - загружает файл из инета)
tar -xvf имя_файла - разархивирую файл (x-разархивация, v-показывать что происходит, f - указывает на файл, который хочу разархивировать)
./configure - в каждой разархивированной проге есть файл configure, а этой командой я его запускаю, на выходе Makefilе, затем запускаю команду make, которая построит прогу. Затем запускаю команду sudo make install, которая проинсталит прогу.

Установка c package manager
для Ubuntu package manager name is apt(на других yam, rpm)
sudo apt-get update - обновляет софт apt
apt-cache search имя_программы - ищу прогу, которую хочу скачать
apt-get install имя_программы - инсталлю прогу
apt-get upgrade - обновляю прогу до последней версии (перед этим делать sudo apt-get update)
apt-get remove имя_программы - удаляю программу (затем apt-git autoremove - если хочу удалить все зависимые программы)

tail -f - выводит строки добавляемые в файл


PropsValues.SESSION_TIMEOUT


Посмотреть на какие порты смотрит nginx
tasklist /fi "imagename eq nginx.exe"
