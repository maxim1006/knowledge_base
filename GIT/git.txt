cat + имя файла - командой cat могу просматривать файлы
touch + имя файла - создаю файл
echo "123" >> text.txt - вставляю 123 в text.txt
ls -a - показать все файлы
mv GIT/ GITEXC - переименовываю GIT в GITEXC
rm -r folder - удаляю папку с именем folder
rm file.txt - удаляю файл с именем file.txt





git config --global --edit - изменить глобальные настройки git вручную
cat ~/.gitconfig - посмотреть глобальный конфиг файл гита

Начальные глобальные настройки
git config --global --list - проверяю глобальные настройки
git config --global user.name "Max"
git config --global user.email "maxim1006@list.ru"
git config --global core.editor sublimetext2
git config --global help.autocorrect 1 - позволяет гиту догадываться о правильных коммандах в случае ошибок
git config --global color.ui auto - задаю автоматические цвета для diff и т.д.
git config --global core.autocrlf true - нужно для конвертации текстовых файлов при передачи на удаленку и обратно




/***********************************  Работа с локальным репозиторием  ****************************/
ls -la - проверяю пустую директорию
git init - делаю репозиторий в этой папке
git status - проверка состояния файлов
git add файл - добавляю файл
git add -u - добавляю апдейченный файл
git commit или git commit -m "" - коммичу с выскакивающим эдитором, либо сразу пишу коммент
git commit -a -m - коммичу все файлы (нужно сперва добавить все файлы, а потом можно сразу коммитить изменения без add)
git log - проверяю логи того что закоммитил


Последовательность коммита: git status --> git add / git add -u --> git commit -m --> git status

git branch new_branch - создаю новую ветку
git branch - показывает все бранчи репозитория
git branch -r - показывает все удаленные бранчи репозитория
git branch -m branch1 branch123 - переименовываю ветку branch1 в branch123
git branch -d + имя ветки - удаляю ветку (если ветка не смерджена пишу так: git branch -D + имя ветки)
git branch + имя бранчи для восстановления + имя коммита(смотрю в git log) - восстановление удаленной бранчи

git diff номер 1 ревизии номер второй ревизии - смотрю разницу между ревизиями
git diff + номер ревизии (например 37782c1153f82db34f3bba5bd13aaaaf8e2741ed) - посмотреть diff (если нужно посмотреть просто последнюю разницу делаю: git diff HEAD)
git diff HEAD~1..HEAD - HEAD - последний коммит, ~1 - первый с конца коммит
git diff --staged - посмотреть, какие изменения сделал

git checkout имя ветки - перехожу на новую ветку 
git checkout -b имя ветки - создаю и перехожу на новую ветку 
git checkout номер файла - переводит файл в состояние коммита, соотв. номеру коммита, (посмотреть номера коммитов git log)
git checkout -- + имя файла - отменяет предыдущее действие на файле (например если я в файле что-то удалил и хочу вернуть)
git checkout HEAD - вернуться к самому свежему коммиту
git checkout HEAD~1 - вернуться к предыдущему коммиту

git reset + имя файла - открепляю файл (если после added хочу открепить)
git reset --soft HEAD~1 - возвращаюсь к предыдущему коммиту, могу при этом исправить что-либо, а потом снова закоммитить
git reset --hard - возвращаю репозиторий к состоянию HEAD, несмотря на удаление файлов и т.д. 

git clean -f - удаляю темпорери файлы (те которые не заапдейтил будут удалены)

.gitignore - файл в котором указываю, какие файлы гит должен игнорить (внутри могу писать /logs, или /logs/*.txt, или logs), дальше добавляю его и коммичу




/***********************************  Работа с удаленным репозиторием  ****************************/
git log - показывает все коммиты
git log --oneline - все коммиты будут в одну строку
git log --oneline --graph - цветные графы с ветками
git log --graph --oneline --all --decorate - цветные графы с ветками и т.д.
git reflog - показывает как меняется метка HEAD
git config --global alias.lga "log --graph --oneline --all --decorate" - делаю алиас на команду git lga
git shortlog - выводит только комментарии коммитов
git shortlog -sne - -s - выводит количество коммитов, сделанных кем-то, n - имя, e - email

git clone + репозиторий - клонирую репозиторий к себе на локальную машину (все коммиты этого репозитория доступны в git log)
git show HEAD - смотрю последний коммит
git show + имя ветки - показывает последний коммит в этой ветке

git tag - показывает все версии проекта

git remote -v - посмотреть все "удаленные" бранчи
git remote, git remote -v - показывает откуда скачал репозиторий (git remote add origin https://github.com/try-git/try_git.git - привязываю локальную копию к удаленной)
git remote add имя_ветки имя_удаленной_папки - добавляю новый удаленный репозиторий под именем к которому будет легче обращаться
git fetch origin master - вытаскивает все изменения с удаленного репозитория
git log origin/master - смотрю логи на удаленной ветви
git merge + имя ветки - сперва перехожу ветку в которую хочу сделать мердж, затем делаю git merge + имя ветки, которую хочу смерджить в текущую, если возникает конфликт, то правлю его в файле удаляю все ненужные и делаю git add имя файла -> git commit
git pull имя_удаленной_ветки имя_локальной_ветки - это тоже самое, что и git fetch + git merge (например git pull origin master)

git tag v1.0 - ставлю метку на последний коммит о том, что это версия 1.0
git push - закидываю файлы на сервер 
git push имя_ветки - закидываю файлы на ветку на сервере (если не указываю, автоматом закидывается в origin)
git push -u origin master - закидываю файлы на сервер с локального репозитория
git push --tags - пушу теги на репозиторий, так как по умолчанию они не пушатся.
git push origin + имя ветки - закидываю новую ветку на удаленку
git push origin :имя ветки - удаляю удаленную ветку

Последовательность для добавления проекта на GITHUB: 

устанавливаю github, затем создаю новый репозиторий на гитхабе, затем закидываю файлы и работаю из powershell внутри github проги.

Или

git remote add origin https://github.com/maxim1006/jQuery.maxcarousel.git -> git push -u origin master (в случае если у меня есть локальный репозиторий, я просто пушу все на удаленку в репозиторий, который создал на гитхабе)

git rm '*.txt' - удаляю все txt файлы
git mergetool - вызываю инструмент для мерджа, например KDiff3
git cherry-pick + номер коммита - сперва захожу в ветку, а потом могу перенести коммит из какой-либо ветки в ту где сейчас нахожусь

/****можно делать git checkout master -> git rebase + имя ветки --> git rebase --continue - перенос какой-либо ветки в master, как будто она всегда там была***/




Подключение kdiff3 в .git/config
[merge]
    tool = kdiff3

[mergetool "kdiff3"]
    path = C:/Program Files (86)/KDiff3/kdiff3.exe
    keepBackup = false
    trustExitCode = false

Можно использовать git flow
https://github.com/nvie/gitflow



//сделать удаленную папку и локальную
git config branch.master.remote origin
git config branch.master.merge refs/heads/master


//посмотреть репозиторий git remote show origin

